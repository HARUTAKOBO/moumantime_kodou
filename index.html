<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>ãƒ©ã‚¤ãƒäº‰å¥ªæˆ¦ æœ€çµ‚ç‰ˆï¼ˆãƒãƒ¼ãƒ‰èª¿æ•´å¯¾å¿œï¼‰</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
body{margin:0;font-family:system-ui;background:#111;color:#fff}
h1{font-size:16px;margin:8px}
.wrap{display:grid;grid-template-columns:260px 1fr;height:100vh}
.panel{background:#222;padding:12px;overflow:auto}
label{font-size:12px;color:#ccc}
input,button{width:100%;margin:6px 0;padding:6px}
canvas{background:#000;touch-action:none}
</style>
</head>
<body>
<h1>ğŸ ãƒ©ã‚¤ãƒäº‰å¥ªæˆ¦ãƒ»æœ€çµ‚ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ï¼ˆãƒãƒ¼ãƒ‰ç§»å‹•å¯¾å¿œï¼‰</h1>
<div class="wrap">
<div class="panel">
<label>æ™‚é–“åœ§ç¸®</label>
<input id="scale" type="number" value="5">
<label>ãƒãƒƒãƒ—é€æ˜åº¦</label>
<input id="alpha" type="number" step="0.1" min="0" max="1" value="0.6">
<button id="reset">ãƒªã‚»ãƒƒãƒˆ</button>
<p style="font-size:12px;line-height:1.4">
ãƒ»ç™½ä¸¸ï¼ˆå®¿èˆ/åˆ†å²ï¼‰ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦èª¿æ•´å¯èƒ½<br>
ãƒ»6è‰²ï¼6ãƒãƒ¼ãƒ æœ€çµ‚å½¢<br>
</p>
</div>
<canvas id="field" width="900" height="1200"></canvas>
</div>
<script>
// ===== æœ€çµ‚ç‰ˆ =====
const canvas = document.getElementById('field');
const ctx = canvas.getContext('2d');
const scaleEl = document.getElementById('scale');
const alphaEl = document.getElementById('alpha');

const bg = new Image();
bg.src = 'map.png';

// ãƒãƒ¼ãƒ‰ï¼ˆã™ã¹ã¦ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½ï¼‰
const nodes = {
  start:{x:450,y:1030,type:'start'},
  a:{x:430,y:900,type:'inn'},
  b:{x:470,y:820,type:'inn'},
  c:{x:430,y:720,type:'inn'},
  fork:{x:480,y:660,type:'fork'},
  d1:{x:420,y:580,type:'inn'},
  d2:{x:540,y:580,type:'inn'},
  merge:{x:480,y:500,type:'merge'},
  e:{x:480,y:420,type:'inn'},
  goal:{x:460,y:220,type:'goal'}
};

const innNodes = Object.keys(nodes).filter(k=>nodes[k].type==='inn');

const routes = [
  {name:'æ¡‚å·', color:'#ff4d4d', path:['start','a','b','c','fork','d1','merge','e','goal']},
  {name:'å¯¿å·', color:'#4dff4d', path:['start','a','b','c','fork','d2','merge','e','goal']},
  {name:'æ±Ÿå·', color:'#4d4dff', path:['start','a','b','c','fork','d2','merge','e','goal']},
  {name:'æ¶ªå·', color:'#ffd24d', path:['start','a','b','c','fork','d1','merge','e','goal']},
  {name:'æ°¸å·', color:'#ff4dff', path:['start','a','b','c','fork','d1','merge','e','goal']},
  {name:'å…‰å·', color:'#4dffff', path:['start','a','b','c','fork','d2','merge','e','goal']}
];

let horses=[];
let dragNode=null;

function resetSim(){
  horses = routes.map(r=>({
    route:r, seg:0, t:0, buff:0,
    pos:{...nodes[r.path[0]]}
  }));
}

// ===== ãƒãƒ¼ãƒ‰ãƒ‰ãƒ©ãƒƒã‚° =====
function getMousePos(e){
  const r = canvas.getBoundingClientRect();
  const x = (e.touches?e.touches[0].clientX:e.clientX)-r.left;
  const y = (e.touches?e.touches[0].clientY:e.clientY)-r.top;
  return {x,y};
}

canvas.addEventListener('mousedown',e=>{
  const m=getMousePos(e);
  for(const k in nodes){
    const n=nodes[k];
    if(Math.hypot(n.x-m.x,n.y-m.y)<12){ dragNode=n; break; }
  }
});
canvas.addEventListener('mousemove',e=>{
  if(!dragNode) return;
  const m=getMousePos(e);
  dragNode.x=m.x; dragNode.y=m.y;
});
canvas.addEventListener('mouseup',()=>dragNode=null);
canvas.addEventListener('mouseleave',()=>dragNode=null);

// touch
canvas.addEventListener('touchstart',e=>{
  const m=getMousePos(e);
  for(const k in nodes){
    const n=nodes[k];
    if(Math.hypot(n.x-m.x,n.y-m.y)<12){ dragNode=n; break; }
  }
});
canvas.addEventListener('touchmove',e=>{
  if(!dragNode) return;
  const m=getMousePos(e);
  dragNode.x=m.x; dragNode.y=m.y;
  e.preventDefault();
});
canvas.addEventListener('touchend',()=>dragNode=null);

function draw(){
  ctx.fillStyle='#203040';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  if(bg.complete && bg.naturalWidth>0){
    ctx.save();
    ctx.globalAlpha=Number(alphaEl.value);
    ctx.drawImage(bg,0,0,canvas.width,canvas.height);
    ctx.restore();
  }

  // ãƒãƒ¼ãƒ‰è¡¨ç¤º
  for(const k in nodes){
    const n=nodes[k];
    ctx.strokeStyle='#fff';
    ctx.beginPath(); ctx.arc(n.x,n.y,8,0,Math.PI*2); ctx.stroke();
    ctx.fillStyle='#fff'; ctx.fillText(k,n.x+10,n.y);
  }

  // é¦¬
  horses.forEach(h=>{
    if(h.seg>=h.route.path.length-1) return;
    const from=nodes[h.route.path[h.seg]];
    const to=nodes[h.route.path[h.seg+1]];
    const dx=to.x-from.x, dy=to.y-from.y;
    const dist=Math.hypot(dx,dy)||1;
    let v=0.5; if(h.buff>0){v=2;h.buff--;}
    h.t+=v*Number(scaleEl.value)/dist;
    if(h.t>=1){ h.seg++; h.t=0; if(innNodes.includes(h.route.path[h.seg])) h.buff=300; }
    h.pos.x=from.x+dx*h.t; h.pos.y=from.y+dy*h.t;
    ctx.fillStyle=h.route.color;
    ctx.beginPath(); ctx.arc(h.pos.x,h.pos.y,10,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#000'; ctx.fillText(h.route.name,h.pos.x+12,h.pos.y);
  });

  requestAnimationFrame(draw);
}

resetSim(); requestAnimationFrame(draw);
document.getElementById('reset').onclick=resetSim;
</script>
</body>
</html>
